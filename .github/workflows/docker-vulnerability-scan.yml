name: Docker Vulnerability Scan with Clair

on:
  push:
    branches: [ main ]
    paths:
      - '**/*.dockerfile'
      - '**/Dockerfile'
      - '**/*.yml'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      image:
        description: "Single Docker image to scan (e.g. python:3.9-slim, nginx:latest)"
        required: false
        default: "nginx:latest"
      image_file:
        description: "Path to a file containing a list of images to scan (one per line)"
        required: false
        default: ""
      whitelist:
        description: "Path to CVE whitelist (YAML)"
        required: false
        default: ""
      severity_threshold:
        description: "Defcon1 | Critical | High | Medium | Low | Negligible | Unknown"
        required: false
        default: "High"
      fail_on_discovered_vulnerabilities:
        description: "Fail on findings at/above threshold"
        required: false
        default: "true"
      fail_on_unsupported_images:
        description: "Fail if image cannot be scanned"
        required: false
        default: "true"
      disable_verbose_console_output:
        description: "Set true to quiet scanner console output"
        required: false
        default: "false"
      docker_tar_dir:
        description: "Directory with Docker image tarballs to load & scan"
        required: false
        default: "/docker-tars"

jobs:
  scan:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalize inputs -> env (with defaults)
        shell: bash
        run: |
          IMAGE="${{ inputs.image }}"
          IMAGE_FILE="${{ inputs.image_file }}"
          WHITELIST="${{ inputs.whitelist }}"
          SEVERITY_THRESHOLD="${{ inputs.severity_threshold }}"
          FAIL_ON_DISCOVERED_VULNS="${{ inputs.fail_on_discovered_vulnerabilities }}"
          FAIL_ON_UNSUPPORTED="${{ inputs.fail_on_unsupported_images }}"
          QUIET="${{ inputs.disable_verbose_console_output }}"
          DOCKER_TAR_DIR="${{ inputs.docker_tar_dir }}"

          : "${IMAGE:=nginx:latest}"
          : "${SEVERITY_THRESHOLD:=High}"
          : "${FAIL_ON_DISCOVERED_VULNS:=true}"
          : "${FAIL_ON_UNSUPPORTED:=true}"
          : "${QUIET:=false}"
          : "${DOCKER_TAR_DIR:=/docker-tars}"
          : "${IMAGE_FILE:=}"
          : "${WHITELIST:=}"

          {
            echo "IMAGE=${IMAGE}"
            echo "IMAGE_FILE=${IMAGE_FILE}"
            echo "WHITELIST=${WHITELIST}"
            echo "SEVERITY_THRESHOLD=${SEVERITY_THRESHOLD}"
            echo "FAIL_ON_DISCOVERED_VULNS=${FAIL_ON_DISCOVERED_VULNS}"
            echo "FAIL_ON_UNSUPPORTED=${FAIL_ON_UNSUPPORTED}"
            echo "QUIET=${QUIET}"
            echo "DOCKER_TAR_DIR=${DOCKER_TAR_DIR}"
          } >> "$GITHUB_ENV"

      - name: Ensure Docker is available
        uses: docker/setup-buildx-action@v3

      - name: Create dirs (reports & optional tar dir)
        run: |
          sudo mkdir -p /clair-reports
          sudo mkdir -p "$DOCKER_TAR_DIR" || true

      - name: Start Clair stack (network + DB + API + scanner)
        shell: bash
        run: |
          set -euxo pipefail
          # 1) sieć użytkownika (stabilna rozdzielczość nazw)
          docker network rm clair-net >/dev/null 2>&1 || true
          docker network create clair-net

          # 2) pobranie obrazów
          docker pull arminc/clair-db:latest
          docker pull arminc/clair-local-scan:latest
          docker pull ovotech/clair-scanner@sha256:8a4f920b4e7e40dbcec4a6168263d45d3385f2970ee33e5135dd0e3b75d39c75

          # 3) DB pod nazwą 'postgres' (tak oczekuje arminc/clair-local-scan)
          docker rm -f postgres clair clair-scanner >/dev/null 2>&1 || true
          docker run -d --name postgres --network clair-net -p 5432:5432 arminc/clair-db:latest

          # 4) Clair v2/v3 API pod nazwą 'clair'
          docker run -d --name clair --network clair-net -p 6060:6060 --link postgres:postgres arminc/clair-local-scan:latest

          # 5) Scanner z publikacją portu 9279 (Clair pobiera warstwy z tego serwera)
          docker run -d --name clair-scanner --network clair-net -p 9279:9279 \
            -v /var/run/docker.sock:/var/run/docker.sock \
            ovotech/clair-scanner@sha256:8a4f920b4e7e40dbcec4a6168263d45d3385f2970ee33e5135dd0e3b75d39c75 tail -f /dev/null

          # 6) Health check Clair (do 180s), z 2 perspektyw:
          #    a) z hosta po mapowanym porcie 6060
          #    b) z wnętrza clair-scanner po DNS "http://clair:6060"
          for i in $(seq 1 90); do
            if curl -sf http://127.0.0.1:6060/ >/dev/null || \
               docker exec clair-scanner sh -lc 'curl -sf http://clair:6060/ >/dev/null'; then
              echo "Clair is responsive"; break
            fi
            echo "Waiting for Clair... ($i/90)"
            sleep 2
          done

          # diagnostyka gdyby nadal nie odpowiadał
          if ! curl -sf http://127.0.0.1:6060/ >/dev/null; then
            echo "Host cannot reach Clair 6060 — dumping recent logs:"
            docker logs --since 2m clair || true
            docker logs --since 2m postgres || true
          fi

      - name: Run clair-scanner (with retries)
        shell: bash
        run: |
          set -euo pipefail

          REPORT_DIR=/clair-reports
          CLAIR=clair
          CLAIR_SCANNER=clair-scanner

          # IP hosta na bridge docker0 (Clair łączy się do serwera warstw na 9279)
          HOST_IP=$(ip -4 addr show docker0 | grep -Po 'inet \K[\d.]+' || true)
          if [ -z "$HOST_IP" ]; then
            HOST_IP=$(ip route | awk '/default/ {print $3}')
          fi
          echo "Using HOST_IP for clair-scanner --ip: $HOST_IP"

          WHITELIST_ARG=""
          if [ -n "${WHITELIST}" ] && [ -f "${WHITELIST}" ]; then
            echo "Using whitelist: ${WHITELIST}"
            docker cp "${WHITELIST}" "${CLAIR_SCANNER}:/whitelist.yml"
            WHITELIST_ARG="-x -w /whitelist.yml"
          fi

          scan() {
            local image="$1"
            echo ">>> Scanning: $image"
            docker pull "$image" || true

            local munged_image
            munged_image=$(echo "$image" | sed 's/\//_/g' | sed 's/:/_/g')
            local out="/${munged_image}.json"

            local ret=0
            local attempt=0
            while :; do
              local cmd=(docker exec -i "$CLAIR_SCANNER" clair-scanner
                --ip "$HOST_IP"
                --clair="http://clair:6060"
                -t "${SEVERITY_THRESHOLD}"
                --report "$out"
                --log "/log.json"
                ${WHITELIST_ARG}
                --reportAll=true
                --exit-when-no-features=false
                "$image")

              if [ "${QUIET}" = "true" ]; then
                "${cmd[@]}" >/tmp/clair-scan.log 2>&1 || ret=$?
              else
                "${cmd[@]}" 2>&1 | tee /tmp/clair-scan.log || ret=$?
              fi

              # Retry, gdy Clair jeszcze nie "widzi" warstw
              if grep -q "could not find layer" /tmp/clair-scan.log && [ $attempt -lt 5 ]; then
                attempt=$((attempt+1))
                echo "Clair not ready for layer yet, retry $attempt/5 in 5s..."
                sleep 5
                continue
              fi
              break
            done

            case "$ret" in
              0) echo "No unapproved vulnerabilities" ;;
              1) echo "Unapproved vulnerabilities found"
                 [ "${FAIL_ON_DISCOVERED_VULNS}" = "true" ] && EXIT_STATUS=1 ;;
              5) echo "Image not scanned (not supported)"
                 [ "${FAIL_ON_UNSUPPORTED}" = "true" ] && EXIT_STATUS=1 ;;
              *) echo "Unknown clair-scanner return code: $ret"; EXIT_STATUS=1 ;;
            esac

            if docker exec "$CLAIR_SCANNER" test -f "$out"; then
              docker cp "${CLAIR_SCANNER}:$out" "${REPORT_DIR}/$(basename "$out")" || true
            else
              echo "No report produced at $out (scan may have failed before report stage)."
            fi
          }

          EXIT_STATUS=0

          if [ -d "${DOCKER_TAR_DIR}" ] && ls -1 "${DOCKER_TAR_DIR}"/*.tar >/dev/null 2>&1; then
            echo "Loading tarballs from ${DOCKER_TAR_DIR}"
            for entry in "${DOCKER_TAR_DIR}"/*.tar; do
              [ -e "$entry" ] || continue
              images=$(docker load -i "$entry" | sed -e 's/Loaded image: //g')
              for image in $images; do scan "$image"; done
            done
          fi

          if [ -n "${IMAGE_FILE}" ] && [ -f "${IMAGE_FILE}" ]; then
            while IFS= read -r img; do
              [ -z "$img" ] && continue
              scan "$img"
            done < "${IMAGE_FILE}"
          fi

          if [ -n "${IMAGE}" ]; then
            scan "${IMAGE}"
          fi

          echo "Reports written to ${REPORT_DIR}"
          exit "${EXIT_STATUS}"

      - name: Upload Clair reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: clair-reports
          path: /clair-reports/*.json
          if-no-files-found: warn

      # ============= TRIVY =============
      - name: Install Trivy
        run: |
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy

      - name: Trivy scan
        run: trivy image "${IMAGE}" --severity HIGH,CRITICAL --format table --timeout 10m > trivy-report.txt || true

      # ============= GRYPE =============
      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh
          sudo mv ./bin/grype /usr/local/bin/
          grype version

      - name: Grype scan
        run: |
          echo "Running Grype on image: ${IMAGE}"
          grype "${IMAGE}" --scope all-layers --only-fixed --output table --file grype-report.txt || true

      # ============= UPLOAD REPORTS =============
      - name: Upload scan reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vulnerability-reports
          path: |
            trivy-report.txt
            grype-report.txt
            /clair-reports/*.json
          if-no-files-found: warn
