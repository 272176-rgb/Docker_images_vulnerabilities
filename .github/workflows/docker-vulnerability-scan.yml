name: Docker Vulnerability Scan with Clair

on:
  push:
    branches: [ main ]
    paths:
      - '**/*.dockerfile'
      - '**/Dockerfile'
      - '**/*.yml'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      image:
        description: "Single Docker image to scan (e.g. python:3.9-slim, nginx:latest)"
        required: false
        default: "nginx:latest"
      image_file:
        description: "Path to a file containing a list of images to scan (one per line)"
        required: false
        default: ""
      whitelist:
        description: "Path to CVE whitelist (YAML)"
        required: false
        default: ""
      severity_threshold:
        description: "Defcon1 | Critical | High | Medium | Low | Negligible | Unknown"
        required: false
        default: "High"
      fail_on_discovered_vulnerabilities:
        description: "Fail on findings at/above threshold"
        required: false
        default: "true"
      fail_on_unsupported_images:
        description: "Fail if image cannot be scanned"
        required: false
        default: "true"
      disable_verbose_console_output:
        description: "Set true to quiet scanner console output"
        required: false
        default: "false"
      docker_tar_dir:
        description: "Directory with Docker image tarballs to load & scan"
        required: false
        default: "/docker-tars"

jobs:
  scan:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout (needed if you reference files in repo)
        uses: actions/checkout@v4

      - name: Set inputs -> env
        run: |
          echo "IMAGE=${{ inputs.image }}" >> $GITHUB_ENV
          echo "IMAGE_FILE=${{ inputs.image_file }}" >> $GITHUB_ENV
          echo "WHITELIST=${{ inputs.whitelist }}" >> $GITHUB_ENV
          echo "SEVERITY_THRESHOLD=${{ inputs.severity_threshold }}" >> $GITHUB_ENV
          echo "FAIL_ON_DISCOVERED_VULNS=${{ inputs.fail_on_discovered_vulnerabilities }}" >> $GITHUB_ENV
          echo "FAIL_ON_UNSUPPORTED=${{ inputs.fail_on_unsupported_images }}" >> $GITHUB_ENV
          echo "QUIET=${{ inputs.disable_verbose_console_output }}" >> $GITHUB_ENV
          echo "DOCKER_TAR_DIR=${{ inputs.docker_tar_dir }}" >> $GITHUB_ENV

      - name: Ensure Docker is available
        uses: docker/setup-buildx-action@v3

      - name: Create dirs (reports & optional tar dir)
        run: |
          mkdir -p /clair-reports
          sudo mkdir -p "$DOCKER_TAR_DIR" || true

      - name: Start Clair (DB + API)
        run: |
          set -euxo pipefail
          docker pull arminc/clair-db:latest
          docker pull arminc/clair-local-scan:latest
          docker run -d --name clair-db -p 5432:5432 arminc/clair-db:latest
          docker run -d --name clair --link clair-db:postgres -p 6060:6060 arminc/clair-local-scan:latest

          # Start the scanner container (we exec into it later)
          docker pull ovotech/clair-scanner@sha256:8a4f920b4e7e40dbcec4a6168263d45d3385f2970ee33e5135dd0e3b75d39c75
          docker run -d --name clair-scanner -v /var/run/docker.sock:/var/run/docker.sock \
            ovotech/clair-scanner@sha256:8a4f920b4e7e40dbcec4a6168263d45d3385f2970ee33e5135dd0e3b75d39c75 tail -f /dev/null

          # Wait for Clair API
          for i in $(seq 1 60); do
            if curl -sf http://127.0.0.1:6060/v1/ >/dev/null || curl -sf http://127.0.0.1:6060/ >/dev/null; then
              echo "Clair is ready"; break
            fi
            echo "Waiting for Clair... ($i/60)"
            sleep 2
          done

      - name: Run clair-scanner (parity with CircleCI orb script)
        shell: bash
        run: |
          set -euo pipefail

          REPORT_DIR=/clair-reports
          CLAIR=clair
          CLAIR_SCANNER=clair-scanner

          # Resolve IPs used by clair-scanner
          clair_ip=$(docker exec -i "$CLAIR" hostname -i | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')
          scanner_ip=$(docker exec -i "$CLAIR_SCANNER" hostname -i | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')

          # Optionally copy whitelist into scanner container
          WHITELIST_ARG=""
          if [ -n "${WHITELIST}" ] && [ -f "${WHITELIST}" ]; then
            echo "Using whitelist: ${WHITELIST}"
            docker cp "${WHITELIST}" "${CLAIR_SCANNER}:/whitelist.yml"
            WHITELIST_ARG="-x -w /whitelist.yml"
          fi

          # Helper to scan a single image
          scan() {
            local image="$1"
            echo ">>> Scanning: $image"

            # Pull image if it's a registry ref (ignore if it's a locally loaded name)
            if [[ "$image" == *":"* || "$image" == *"/"* ]]; then
              docker pull "$image" || true
            fi

            local munged_image
            munged_image=$(echo "$image" | sed 's/\//_/g' | sed 's/:/_/g')
            local out="/${munged_image}.json"

            local cmd=(docker exec -i "$CLAIR_SCANNER" clair-scanner
              --ip "$scanner_ip"
              --clair="http://${clair_ip}:6060"
              -t "${SEVERITY_THRESHOLD}"
              --report "$out"
              --log "/log.json"
              ${WHITELIST_ARG}
              --reportAll=true
              --exit-when-no-features=false
              "$image")

            local ret=0
            if [ "${QUIET}" = "true" ]; then
              "${cmd[@]}" >/dev/null 2>&1 || ret=$?
            else
              "${cmd[@]}" 2>&1 || ret=$?
            fi

            case "$ret" in
              0) echo "No unapproved vulnerabilities" ;;
              1) echo "Unapproved vulnerabilities found"
                 [ "${FAIL_ON_DISCOVERED_VULNS}" = "true" ] && EXIT_STATUS=1 ;;
              5) echo "Image not scanned (not supported)"
                 [ "${FAIL_ON_UNSUPPORTED}" = "true" ] && EXIT_STATUS=1 ;;
              *) echo "Unknown clair-scanner return code: $ret"; EXIT_STATUS=1 ;;
            esac

            docker cp "${CLAIR_SCANNER}:$out" "${REPORT_DIR}/$(basename "$out")" || true
          }

          EXIT_STATUS=0

          # Option A: Docker tarballs
          if [ -d "${DOCKER_TAR_DIR}" ] && ls -1 "${DOCKER_TAR_DIR}"/*.tar >/dev/null 2>&1; then
            echo "Loading tarballs from ${DOCKER_TAR_DIR}"
            for entry in "${DOCKER_TAR_DIR}"/*.tar; do
              [ -e "$entry" ] || continue
              images=$(docker load -i "$entry" | sed -e 's/Loaded image: //g')
              for image in $images; do scan "$image"; done
            done
          fi

          # Option B: image_file (one image ref per line)
          if [ -n "${IMAGE_FILE}" ] && [ -f "${IMAGE_FILE}" ]; then
            while IFS= read -r img; do
              [ -z "$img" ] && continue
              scan "$img"
            done < "${IMAGE_FILE}"
          fi

          # Option C: single image input
          if [ -n "${IMAGE}" ]; then
            scan "${IMAGE}"
          fi

          echo "Reports written to ${REPORT_DIR}"
          exit "${EXIT_STATUS}"

      - name: Upload Clair reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: clair-reports
          path: /clair-reports/*.json
          if-no-files-found: warn

      # (Optional) Keep your other scanners â€” they complement Clair nicely.
      # Example: Trivy + Grype from your original workflow
      - name: Install Trivy
        run: |
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
      - name: Trivy scan
        run: trivy image "${IMAGE}" --severity HIGH,CRITICAL --format table > trivy-report.txt || true
      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh
          sudo mv ./bin/grype /usr/local/bin/
          grype version
      - name: Grype scan
        run: grype "${IMAGE}" --only-fixed --output table > grype-report.txt || true
      - name: Upload Trivy/Grype reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: extra-reports
          path: |
            trivy-report.txt
            grype-report.txt
          if-no-files-found: warn
